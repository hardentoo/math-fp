#+TITLE:  Monads and other abstractions
#+AUTHOR: John Wiegley
#+EMAIL:  johnw@newartisans.com
#+DATE:   22 Jul 2014

#+DESCRIPTION: Applying mathematical abstractions to functional programming
#+KEYWORDS: math monad haskell functional programming
#+LANGUAGE: en

\setbeamertemplate{footline}{}
\setbeamerfont{block body}{size=\small}
\definecolor{orchid}{RGB}{134, 134, 220}
\setbeamercolor{block title}{fg=white,bg=orchid}
\setbeamercolor{bgcolor}{fg=white,bg=blue}

* Overview
** Workshop overview
1. Basic math definitions
2. Algebras and laws
3. Working with proofs
4. Category theory & Functors
5. Monads
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Give an introduction of myself and my background here, and ask whether people
in the audience have much experience with the intersection between math and
programming.
* Mathematics
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Mathematics}
** Meaning
There isn't any.
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
One of the things that tripped me up most when I started studying math was my
desire for meaning: for examples that would motivate and explain what the
concept was "about" or "for".
** Abstraction
Structures, and relationships between structures.
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Math is really a language, a whole system, for talking about structures and
their relationships.  Meaning and abstraction form a kind of tension, since
you move away from meaning into abstraction, and to gain meaning you must give
up abstraction.
* Sets
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Sets}
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
What is really interesting is just how much can be done with such a minimal
amount of structure.
** ``Stuff''
\begin{center}
\includegraphics[width=.65\linewidth]{images/Sets1.pdf}
\end{center}
** ``Stuff''
\begin{center}
\includegraphics[width=.65\linewidth]{images/Sets2.pdf}
\end{center}
** Sets of sets
\begin{center}
\includegraphics[width=.65\linewidth]{images/Sets3.pdf}
\end{center}
** Extensional
Can be defined by stating its elements.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
\( \{ \ True, False\ \} \)
** Intensional
Or by describing them.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
\( \{ \ x \ |\  x \in \mathbb{N}, even(x)\ \} \)
** Programmatic
Can be modeled programmatically.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
type Set a = a -> Bool

import Data.Set as S
type Set a = S.Set a
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
This introduces the idea of modeling constructs as functions instead of data
structures.
** Exercise
Using the functional definition of sets, define union and intersection.
*** \vspace*{-3.5ex}                                                               :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
type Set a = a -> Bool

union :: Set a -> Set a -> Set a
inter :: Set a -> Set a -> Set a
\end{lstlisting}
#+END_LaTeX
** Deceptively simple
With a basic definition and seven axioms (we've seen two!), you can generate a
good deal of mathematics.
* Functions
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: fram.
:END:
\head{Functions}
** Domain, co-domain, range
\begin{center}
\includegraphics[width=.9\linewidth]{images/Codomain2.pdf}
\end{center}
** Injective
\begin{center}
\includegraphics[width=.9\linewidth]{images/Mappings1.pdf}
\end{center}
** Injective
\[ f : A → B \]

\[ ∀ x, y ∈ A \]

\[ f\ x = f\ y → x = y \]
** Injective
Examples of injective things:

- Data constructors
- Type constructors
- But not type synonyms\dots{}
** Exercise
1. Write an injective function on \texttt{Integer}, and one that is not
   injective.

2. How do you test it in both cases?
** Surjective
\begin{center}
\includegraphics[width=.9\linewidth]{images/Mappings2.pdf}
\end{center}
** Surjective
\[ f : A → B \]

\[ ∀ y ∈ B, ∃ x ∈ A \]

\[ f\ x = y \]
** Surjective
A function is surjective if the set of possible results is not a subset of its
type.  Example:

- \texttt{even} is surjective
- \texttt{times2} is not
** Bijective
\begin{center}
\includegraphics[width=.9\linewidth]{images/Mappings3.pdf}
\end{center}
** Higher-order functions
*** Identity                                                                       :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( id\ x = x \)
*** Composition                                                                    :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( (f ∘ g)\ x = f (g(x)) \)
** Properties of functions
\[ f : dom → cod \]
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
A powerful concept is to define properties of functions in terms of functions
and equalities.
*** Idempotent                                                                     :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( f ∘ f = f \)
*** Involutive                                                                     :B_definition:
:PROPERTIES:
:BEAMER_act: <3->
:BEAMER_env: definition
:END:
\( f ∘ f = id \)
** More properties
*** Section                                                                        :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( f ∘ s = id \)
*** Retract                                                                        :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( r ∘ f = id \)
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
I only mention these to show how much structures we can infer from a very
small set of building blocks.
** Exercise
For the set of integers, show examples of:

1. idempotency
2. involution
3. section
4. retraction
** Isomorphism
An isomorphism is a pair of functions satisfying two equations:

\[ f ∘ g = id_{cod(f)} \]
\[ g ∘ f = id_{cod(g)} \]
** Isomorphism
In terms of the types involved:

\[ A ≅ B \]

\[ g : A → B \]
\[ f : B → A \]
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Assuming of course \( cod(f) = A, cod(g) = B \).
** Exercise
\vspace{-2ex}
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Unit = Unit
data Maybe a = Nothing | Just a
\end{lstlisting}
#+END_LaTeX
*** Write two functions                                                            :B_alertblock:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: alertblock
:END:
\fontsize{14}{16}\selectfont
\vspace{-2ex}
\begin{align*}
\texttt{toMaybe}   & :: \texttt{Integer}\ →\ \texttt{Maybe\ Unit} \\
\texttt{fromMaybe} & :: \texttt{Maybe\ Unit}\ →\ \texttt{Integer}
\end{align*}
* Laws
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Laws}
** Imposed structure
In the absence of meaning, laws create structure.
** Principled restriction
Laws restrict how functions and values relate to each other.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Monoid a where
    mempty  :: a
    mappend :: a -> a -> a
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Give the example of why mempty from Monoid is good, but point from Pointed is
not.
** Associativity
\[ x ∙ (y ∙ z) = (x ∙ y) ∙ z \]
** Commutativity
\[ x ∙ y = y ∙ x \]
** Transitivity
\[ x ∙ y → y ∙ z → x ∙ z \]
** Lawless!
Behold, the face of evil:
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Pointed a where
    point :: a
\end{lstlisting}
#+END_LaTeX
* [Questions?]
** [Questions?]
\begin{center}
\includegraphics[width=.9\linewidth]{images/flip-concatmap.jpg}
\end{center}
* Algebras
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Algebras}
** Sets with structure
Algebras are basically:
- a set (called the /carrier/)
- functions closed over the set
- laws to govern these functions
** Named structures
Some structures recur often enough that it's useful to name them, but the
names are arbitrary.
** Magma
\[ (S, s → s → s) \]

\vspace{2em}
The set of laws is empty!
** Magma
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Magma a where
    binop :: a -> a -> a

instance Magma Integer where
    binop = (+)
\end{lstlisting}
#+END_LaTeX
** Semigroup
\[ (S, s → s → s) \]

Laws:

1. associativity
** Semigroup
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Semigroup a where
    (<>) :: a -> a -> a
\end{lstlisting}
#+END_LaTeX
*** Semigroup law
:PROPERTIES:
:BEAMER_act: <2->
:END:
\vspace{-3.5ex}
\begin{align*}
a ⊕ (b ⊕ c) &= (a ⊕ b) ⊕ c
\end{align*}
** Monoid
\[ (S, ε, s → s → s) \]

Laws:

1. left identity
2. right identity
3. associativity
** Monoid
\vspace{-2ex}
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Monoid a where
    mempty  :: a
    mappend :: a -> a -> a
\end{lstlisting}
#+END_LaTeX
*** Monoid laws                                                                    :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:END:
\vspace{-3.5ex}
\begin{align*}
ε ⊕ a &= a \\
a ⊕ ε &= a \\
a ⊕ (b ⊕ c) &= (a ⊕ b) ⊕ c
\end{align*}
** Group
\[ (S, ε, s → s → s, s → s) \]

Laws:

1. left identity
2. right identity
3. associativity
4. inverse elements
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Note that the only difference here is in the laws, not the operations.
** Group
*** Group laws
\vspace{-3.5ex}
\begin{align*}
ε ⊕ a &= a \\
a ⊕ ε &= a \\
a ⊕ (b ⊕ c) &= (a ⊕ b) ⊕ c \\
a ⊕ a^{-1} &= ε
\end{align*}
** Homomorphism
``Structure preserving.''
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
floor :: Float -> Int
\end{lstlisting}
#+END_LaTeX
** Free objects
What if our monoid, instead of /doing something/, only constructed values?
** Free objects
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data MV a = MEmpty
          | Var a
          | MAppend (MV a) (MV a)

instance Monoid (MV a) where
    mempty  = MEmpty
    mappend = MAppend 
\end{lstlisting}
#+END_LaTeX
** Building trees
\[ (a ⊕ b) ⊕ c ⊕ (d ⊕ e) \]
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
 (Var a `MAppend` Var b)
   `MAppend`
 Var c
   `MAppend`
 (Var d `MAppend` Var e)
\end{lstlisting}
#+END_LaTeX
** Using the laws
Due to the law of associativity, calls to \texttt{mappend} can always be
re-associated:

\[ a ⊕ (b ⊕ (c ⊕ (d ⊕ e))) \]
** Using the laws
This changes the expression into something linear, rather than a tree:
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
 Var a `MAppend`
 (Var b `MAppend`
  (Var c `MAppend`
   (Var d `MAppend`
    (Var e `MAppend` MEmpty))))
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
This structure should look familiar...
** Using the laws
Relying on this law, we can simplify the data type:
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data MV a = MEmpty
          | MAppend a (MV a)
\end{lstlisting}
#+END_LaTeX
** Using the laws
Let's rename the constructors to something more familiar:
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data List a = Nil
            | Cons a (List a)
\end{lstlisting}
#+END_LaTeX
** Data structures
Free objects of an algebra become data structures in programming.
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Free semigroups are non-empty lists.  Free groups are lists that allow members
to be removed by appending an inverse value.
** Folding
Choosing operations for an algebra is equivalent to folding over its free
object.
** Evaluators
The two essential aspects of an algebra are:

- Forming expressions
- Evaluating these expressions
** Free functors
Every free object is trivially a functor, called a free functor.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
instance Functor List where
    fmap _ Nil = Nil
    fmap f (Cons x xs)
        = Cons (f x) (fmap f xs)
\end{lstlisting}
#+END_LaTeX
** F-algebras
We can encode other algebras using functions and free functors:
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
type Algebra f a = f a -> a

sum :: Algebra List Int
sum Nil = 0
sum (Cons x xs) = x + sum xs
\end{lstlisting}
#+END_LaTeX
** Recursion schemes
We won't cover it, but the recursion can be abstracted away for an even more
general form: \\
\vspace{1ex}
\fontsize{14}{14}\selectfont
https://www.fpcomplete.com/user/bartosz/understanding-algebras
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
This can have speed benefits by improving optimization opportunities, and can
make otherwise recursive algorithms much simpler to write.
** Computational structures
Every free functor can be modeled as a computation rather than as an ADT:

\[ \texttt{List}\ a \ ≅ \ ∀ r, r → (a → r → r) → r \]
** Proving isomorphism
Proof of an isomorphism requires four things:

1. Write a $\texttt{to}$ function.
2. Write a $\texttt{from}$ function.
3. Show: $∀ x, to\ (from\ x) = x$.
4. Show: $∀ y, from\ (to\ y) = y$.
** QuickCheck
In lieu of real proofs, we can sometimes pick types and just use QuickCheck.
** Exercise
Prove the following isomorphisms:
\begin{align*}
  \texttt{Identity}\ a \ ≅  & \ ∀ r, (a → r) → r            \\
     \texttt{Maybe}\ a \ ≅  & \ ∀ r, r → (a → r) → r        \\
\texttt{Either}\ a \ b \ ≅  & \ ∀ r, (a → r) → (b → r) → r  \\
                (a, b) \ ≅  & \ ∀ r, (a → b → r) → r        \\
      \texttt{List}\ a \ ≅  & \ ∀ r, r → (a → r → r) → r
\end{align*}
** Exercise
Easy:
- Write \texttt{head} for both forms of list.
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
    head :: List a -> a
    head :: [a] -> a
\end{lstlisting}
#+END_LaTeX

Hard:
- Write \texttt{tail} for both forms of list.
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
    tail :: List a -> List a
    tail :: [a] -> [a]
\end{lstlisting}
#+END_LaTeX
** Types are algebras too
\vspace{-2ex}
\begin{align*}
a + b &= \texttt{Either}\ a\ b                   \\
      &= \texttt{Foo}\ a\ |\ \texttt{Bar}\ b     \\[1ex]
a * b &= (a, b)                                  \\
      &= \texttt{Foo}\ a\ b                      \\[1ex]
b^{a} &= a → b                                   \\
1     &= \texttt{Foo}                            \\
0     &= \texttt{Void}                
\end{align*}
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Why is this good?  Because you can apply algebraic manipulations to types to
derive other types.
** Which algebra is it?
A *near-semiring* structure over the set $S$ of types.

1. $(S, +, 0)$ is a monoid
2. $(S, *)$ is a semigroup
3. $∀ a, b, c ∈ S, (a + b) * c = a * c + b * c$
4. $∀ a ∈ S, 0 * a = 0$
** Example: currying
\[ (c^{b})^{a} = c^{b a} \]

#+BEGIN_LaTeX
\vspace{1ex}
\begin{center}
\begin{lstlisting}[language=Haskell]
   a -> b -> c  <>  (a, b) -> c
\end{lstlisting}
\end{center}
#+END_LaTeX
** Example: lists
\vspace{-2ex}
\begin{align*}
L(a) &= 1 + a ∙ L(a)                                      \\
     &= 1 + a ∙ (1 + a ∙ L(a))                            \\
     &= 1 + a + a^{2} ∙ (1 + a ∙ L(a))                    \\
     &= 1 + a + a^{2} + a^{3} ∙ (1 + a ∙ L(a))            \\
     &= \cdots{}                                          \\
     &= 1 + a + a^{2} + a^{3} + a^{4} + a^{5} + \cdots{}
\end{align*}
** Example: lists
\vspace{-2ex}
\begin{align*}
CL(a) &= ∀ r, r → (a → r → r) → r     \\
      &= ∀ r, (r^{(a → r → r)})^{r}   \\
      &= ∀ r, (r^{((r^{r})^{a})})^{r} \\
      &= ∀ r, r^{(r ∙ r^{(r ∙ a)})}   \\
      &= ∀ r, r^{r^{(1 + a ∙ r)}}
\end{align*}
* [Break]
** [Break]
\begin{center}
\includegraphics[width=.9\linewidth]{images/tail-recursion.jpg}
\end{center}
* Equational Reasoning
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Equational Reasoning}
** Working with proofs
Equational reasoning gives us a way to reason about pure computations.
** Basic format
\begin{align*}
x  &= y                      \\
   &= y'  \tag*{reason}      \\
   &= y'' \tag*{reason}      \\
   &= x   \tag*{reason}
\end{align*}
** Example
\fontsize{14}{16}\selectfont
\begin{align*}
f ∘ (g ∘ h) &= (f ∘ g) ∘ h                          \\
            &= (λx → f\ (g\ x)) ∘ h
               \tag*{\textbf{unfold ∘}}             \\
            &= λy → (λx → f\ (g\ x))\ (h\ y)
               \tag*{\textbf{unfold ∘}}             \\
            &= λy → f\ (g\ (h\ y))
               \tag*{\textbf{β-reduction}}          \\
            &= λy → f\ ((g ∘ h)\ y)
               \tag*{\textbf{fold ∘}}               \\
            &= λy → (f ∘ (g ∘ h))\ y
               \tag*{\textbf{fold ∘}}               \\
            &= f ∘ (g ∘ h)
               \tag*{\textbf{η-contraction}}        \\
            &  \tag*{\qed{}}
\end{align*}
* Quantification
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Quantification}
** Existential
\[ \exists x, P\ x \]
** Universal
\[ \forall x, P\ x \]
** Universal
*** True?                                                                          :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
\( ∀ x, ∃ y → x = y \)
** Universal
*** True?                                                                          :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
\( ∀ x, ∃ y → x ‌≠ y \)
** Existential
*** True?                                                                          :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
\( ∃ y → ∀ x, x ‌= y \)
*** True?                                                                          :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
\( ∃ y → ∀ x, x ‌≠ y \)
** Relationship
\[ ∃x, φ(x) \ \ ≡ \ \ ¬∀x, ¬φ(x) \]
** As a game
You can think of quantification like a game between two players, the caller
and the callee:

- ∀ means the caller gets to decide the object
- ∃ means the callee gets to decide
** As a game
When we prove, or a write a function, we are the callee.  When we call a
function or apply a lemma, we are the caller.
** Switching roles
It's possible to switch roles inside a function:

\[ ∀ x, (∀ y, y → r) → x → r \]
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Show how this is the case.  In Haskell we call this a Rank-2 function type.
Our computational data types made use of them.
* Parametricity
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Parametricity}
** Theorems for free!
What does the following type imply (assuming no ⊥)?
\vspace{1.5ex}
*** filter                                                                            :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
filter :: (a -> Bool) -> [a] -> [a]
filter f xs = _
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
There's a law that I will not be able to violate when writing this function.
It is "proven by construction".  This is one of the more powerful concepts of
polymorphic programming in functional languages.
** Theorems for free!
*** filter                                                                            :B_theorem:
:PROPERTIES:
:BEAMER_env: theorem
:END:
\vspace{1ex}
\( ∀ g : a → b \) \\
\vspace{1ex}
\( ∀ p : a → {\tt Bool} \)

\( ∀ q : b → {\tt Bool} \)
\begin{flalign*}
∀ x, p\ x = q\ (g\ x) ⟶ & \\
  \vspace{1ex}\hspace{2em}map\ g\ (\textbf{filter}\ p\ xs)
    &= \textbf{filter}\ q\ (map\ g\ xs) &
\end{flalign*}
** Why is it free?
It's not just that the type implies the theorem: Writing such a function is
also a proof of the theorem.
** Free theorem generator
Automatically generate free theorems for sub-languages of Haskell: \\
\vspace{1ex}
\fontsize{14}{14}\selectfont
http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Sub-languages include: no bottoms (hence no general recursion and no selective
strictness); general recursion but no selective strictness; general recursion
and selective strictness.
** Further reading
\fontsize{14}{16}\selectfont
http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
** Curry-Howard Isomorphism
\begin{center}
\begin{tabular}{ l l c || c l r }
&        & & &          & \\
& Types  & & & Theorems & \\
&        & & &          & \\ \hline
&        & & &          & \\
& Values & & & Proofs   & \\
&        & & &          & \\
\end{tabular}
\end{center}
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
When we state a type, that's the same as formulating a theorem using the
language of types.  Finding an inhabitant of that type establishes an
existence proof for the theorem.  Programmers are actual posing theorems and
constructing proofs all the time without realizing it.
* Category Theory
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Category Theory}
** Category
\begin{center}
\includegraphics[width=.9\linewidth]{images/Category1.pdf}
\end{center}
** Not all sets
Instead of sets with elements and functions, we have categories with objects
and morphisms.

\vspace{2ex}All sets are categories, but not vice-versa.
** Example: Any set
\begin{description}[style=nextline]
  \item[Objects]   Set elements
  \item[Morphisms] Just the identities (a \textbf{discrete} category)
\end{description}
** Example: Posets
\begin{description}[style=nextline]
  \item[Objects]     Set elements
  \item[Morphisms]   Identities and $≤$ between some elements
  \item[Composition] {\small $(y ≤ z) ∘ (x ≤ y) = (x ≤ z)$}
\end{description}
** Example: Graphs
\begin{description}[style=nextline]
  \item[Objects]     Vertices
  \item[Morphisms]   Edges and self-edges (bidirectional if undirected)
  \item[Composition] In the ``obvious'' way.
\end{description}
** Example: Set
\begin{description}[style=nextline]
  \item[Objects]     Sets
  \item[Morphisms]   Functions
  \item[Composition] As functions do
\end{description}
** Example: Mon
\begin{description}[style=nextline]
  \item[Objects]     Sets with monoid structure
  \item[Morphisms]   Monoid homomorphisms
  \item[Composition] As functions do
\end{description}
** Example: Cat
\begin{description}[style=nextline]
  \item[Objects]     Categories
  \item[Morphisms]   Functors
  \item[Composition] As functions do
\end{description}
** Example: Fun(C,D)
\begin{description}[style=nextline]
  \item[Objects]     Functors $C → D$
  \item[Morphisms]   Natural transformations
  \item[Composition] As polymorphic functions
\end{description}
** Many categories
Any book on category theory will have many more examples of categories than
these few.
** Some books
- Lawvere, /Conceptual Mathematics: A First Introduction to Categories/
- Awodey, /Category Theory/
- Mac Lane, /Categories for the Working Mathematician/
** Other resources
- Catster's videos: \\
  \small http://byorgey.wordpress.com/catsters-guide-2 \normalsize
- Awodey's presentation on Category Theory at OPLSS 2013
- ##categorytheory on IRC
** Concepts transfer
One of the profound concepts in category theory is how ideas transfer.
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
And yet, all of this is rooted in a profound simplicity.
* Functors
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Functors}
** Categorical model
\begin{center}
\includegraphics[width=\linewidth]{images/Functors1.pdf}
\end{center}
** Unit mapping
\begin{center}
\includegraphics[width=\linewidth]{images/Functors2.pdf}
\end{center}
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
In Haskell, this is called Const.
** Definition in code
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Functor f where
  fmap :: (a -> b) -> (f a -> f b)
\end{lstlisting}
#+END_LaTeX
** Functor laws
*** 1. Identity law                                                                :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( fmap\ id = id \)
*** 2. Composition law                                                             :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( fmap\ (f ∘ g) = fmap\ f ∘ fmap\ g \)
** Not containers!
A *Functor* can sometimes map to:
- a container
- a computation
\dots{}but a *Functor* /per se/ is neither.
** As Context
:PROPERTIES:
:BEAMER_env: frame
:END:
\fontsize{42}{36}\selectfont
\[ \textbf{F}\ {\tt a} \]
** Don't be fooled
*Functors* are humble, but powerful.
** Origins
*** Eilenberg and Mac Lane                                                          :B_quotation:
:PROPERTIES:
:BEAMER_env: quotation
:END:
\noindent Their [Eilenberg and Mac Lane's] goal was to understand natural
transformations; in order to do that, functors had to be defined, which
required categories.

-- Wikipedia
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    fmap f (Identity x) = ?
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Identity as a concept can be used to implement "taintedness", to force
laziness, to provide singletons, and more.  As should be clear by now, the
simplicity of a core idea can be misleading.
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    fmap f (Identity x) = Identity (f x)
\end{lstlisting}
#+END_LaTeX
** Proving Identity Law
\fontsize{12}{16}\selectfont
\begin{align*}
id\ {\tt x}              &= fmap\ id\ {\tt x}                      \\
                         &                                         \\
id\ ({\tt Identity\ x′}) &= fmap\ id\ ({\tt Identity\ x′})
                            \tag*{\textbf{unfold {\tt x}}}         \\
                         &= {\tt Identity}\ (id\ {\tt x′})
                            \tag*{\textbf{defn. {\tt fmap}}}       \\
{\tt Identity\ x′}       &= {\tt Identity\ x′}
                            \tag*{\textbf{defn. {\tt id}}}
\end{align*}
** Proving Composition
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}fmap\ (f ∘ g)\ {\tt x}             \\
 &= fmap\ (f ∘ g)\ ({\tt Identity\ x′})
    \tag*{\textbf{unfold {\tt x}}}                   \\
 &= {\tt Identity}\ ((f ∘ g)\ {\tt x′})
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= {\tt Identity}\ (f (g ({\tt x′})))
    \tag*{\textbf{defn. ∘}}                          \\
 &= fmap\ f\ ({\tt Identity} (g ({\tt x′})))
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= fmap\ f\ (fmap\ g\ ({\tt Identity\ x′}))
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= fmap\ f\ (fmap\ g\ {\tt x})
    \tag*{\textbf{fold {\tt x}}}
\end{align*}
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    fmap f Nothing  = ?
    fmap f (Just x) = ?
\end{lstlisting}
#+END_LaTeX
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    fmap f Nothing  = Nothing
    fmap f (Just x) = Just (f x)
\end{lstlisting}
#+END_LaTeX
** Either                                                                             :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Left e a = Left e | Right a
\end{lstlisting}
#+END_LaTeX
** Tuple                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Pair p a = Pair p a
\end{lstlisting}
#+END_LaTeX
** Const                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Const c a = Const c
\end{lstlisting}
#+END_LaTeX
** Exercise
Remember how free functors were encoded as functions?  This extends to *any*
functor:

\[ f\ a \ ≅ \ ∀ r, (a → r) → f\ r \]
** Exercise
\fontsize{14}{16}\selectfont
\vspace{-2ex}
\begin{align*}
\texttt{lower} & \ :: \ (∀ r.\ (a → r) → f\ r) \ → \ f\ a                    \\
               &                                                             \\
\texttt{lift}  & \ :: \ \texttt{Functor}\ f \ ⇒ \ f\ a \ → \ (a → r) → f\ r
\end{align*}
** Yoneda lemma
You just proved the Yoneda lemma in a functional language!
** Exercise
A Yoneda embedding is itself a *Functor*:

#+BEGIN_LaTeX
\vspace{2ex}
\lstset{basicstyle=\footnotesize\ttfamily}
\begin{lstlisting}[language=Haskell]
data Yoneda f a
    = Yoneda (forall r. (a -> r) -> f r)

instance Functor (Yoneda f) where
    fmap g (Yoneda k) = ?
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Identity as a concept can be used to implement "taintedness", to force
laziness, to provide singletons, and more.  As should be clear by now, the
simplicity of a core idea can be misleading.
** Concepts lift
A lot of what we know about values can be lifted to functors.
** Lifted Identity
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data IdentityF f a
    = IdentityF (f a)
\end{lstlisting}
#+END_LaTeX
** Lifted Maybe
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data MaybeF f a
    = NothingF a | Just (f a)
\end{lstlisting}
#+END_LaTeX
** Lifted Either
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data EitherF f g a
    = LeftF (f a) | RightF (g a)
\end{lstlisting}
#+END_LaTeX
** Lifted Tuple
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data TupleF f a
    = TupleF (f (f a))
\end{lstlisting}
#+END_LaTeX
** Lifted List
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data ListF f a
    = NilF a
    | ListF (f (ListF f a))
\end{lstlisting}
#+END_LaTeX
** Free Monad
We could rename the constructors of our lifted list:

#+BEGIN_LaTeX
\vspace{2ex}
\begin{lstlisting}[language=Haskell]
data FreeMonad m a
    = Return a
    | Join (m (FreeMonad m a))
\end{lstlisting}
#+END_LaTeX
** Famous quote
\begin{quotation}
\noindent ``A monad is just a monoid in the category of endofunctors, what's the
problem?'' \\
-- Saunders Mac Lane
\end{quotation}

\vspace{2ex}Likewise, our free monad is just a free monoid over functors.
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
We're not going to discuss this just now, but we're going to come back it.
* Applicatives
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Applicatives}
** Definition in code
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Applicative f where
  pure  :: f a
  (<*>) :: f (a -> b) -> f a -> f b
\end{lstlisting}
#+END_LaTeX
** Important
One aspect of \texttt{Applicative} gives a clue to its power:

\vspace{2ex}The \texttt{<*>} operator takes *two* functorial arguments.
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
This is not true of either Functor or Monad.
** Applicative laws
*** 1. Identity law                                                                :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( pure\ id ⊗ v = v \)
*** 2. Composition law                                                             :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( pure\ (∘) ⊗ u ⊗ v ⊗ w = u ⊗ (v ⊗ w) \)
*** 3. Homomorphism law                                                            :B_definition:
:PROPERTIES:
:BEAMER_act: <3->
:BEAMER_env: definition
:END:
\( pure\ f ⊗ pure\ x = pure\ (f(x)) \)
** Applicative laws
*** 4. Interchange law                                                             :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( u ⊗ pure\ y = pure\ (\$\ y) ⊗ u \)
*** 5. Functor relation law                                                        :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( pure\ f ⊗ x = fmap\ f\ x \)
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Applicative Identity where
    pure x = Identity x
    Identity f <*> Identity x = ?
\end{lstlisting}
#+END_LaTeX
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Applicative Identity where
    pure x = Identity x
    Identity f <*> Identity x
        = Identity (f x)
\end{lstlisting}
#+END_LaTeX
** Proving Identity
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}pure\ id ⊗ {\tt v}                 \\
 &= pure\ id ⊗ {\tt Identity\ v}
    \tag*{\textbf{unfold {\tt v}}}                   \\
 &= {\tt Identity}\ id ⊗ {\tt Identity\ v}
    \tag*{\textbf{defn. {\tt pure}}}                 \\
 &= {\tt Identity}\ (id\ {\tt v})
    \tag*{\textbf{defn. ⊗}}                          \\
 &= {\tt Identity\ v}
    \tag*{\textbf{defn. {\tt id}}}                   \\
 &= {\tt v}
    \tag*{\textbf{fold {\tt v}}}
\end{align*}
** Proving Homomorphism
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}pure\ f ⊗ pure\ x                 \\
 &= {\tt Identity}\ f ⊗ {\tt Identity}\ x
    \tag*{\textbf{defn. {\tt pure}}}                 \\
 &= {\tt Identity}\ (f(x))
    \tag*{\textbf{defn. ⊗}}                          \\
 &= pure\ (f(x))
    \tag*{\textbf{defn. {\tt pure}}}
\end{align*}
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Applicative Maybe where
    pure x = ?

    Nothing <*> Nothing = ?
    Just f  <*> Nothing = ?
    Nothing <*> Just x  = ?
    Just f  <*> Just x  = ?
\end{lstlisting}
#+END_LaTeX
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Applicative Maybe where
    pure x = ?

    Just f <*> Just x = Just (f x)
    _      <*> _      = Nothing
\end{lstlisting}
#+END_LaTeX
** Either                                                                             :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Left e a = Left e | Right a
\end{lstlisting}
#+END_LaTeX
** Tuple                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Pair p a = Pair p a
\end{lstlisting}
#+END_LaTeX
** Const                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
**Const** requires a trickier instance.
\vspace{1.5ex}
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Const c a = Const c

instance Monoid c
    => Applicative (Const c) where
    pure x = ?
    Const a <*> Const b = ?
\end{lstlisting}
#+END_LaTeX
* [Break]
** [Break]
\begin{center}
\includegraphics[width=.9\linewidth]{images/monad-tutorial.jpg}
\end{center}
* Monads
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Monads}
** Two formulations
*** Using bind                                                                     :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
return :: m a
(>>=)  :: m a -> (a -> m b) -> m b
\end{lstlisting}
#+END_LaTeX
*** Using join                                                                     :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
return :: m a
join   :: m (m a) -> m a
\end{lstlisting}
#+END_LaTeX
** Bind in terms of join                                                           :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
m >>= f = join (fmap f m)
\end{lstlisting}
#+END_LaTeX
** Monad laws
*** 1. Left identity law                                                           :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( return\ a >>= f = f a \)
*** 2. Right identity Law                                                          :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( m >>= return = m \)
*** 3. Associativity Law                                                           :B_definition:
:PROPERTIES:
:BEAMER_act: <3->
:BEAMER_env: definition
:END:
\( (m >>= f) >>= g = m >>= (λx → f\ x >>= g) \)
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    Identity m >>= f = ?
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Identity as a concept can be used to implement "taintedness", to force
laziness, to provide singletons, and more.  As should be clear by now, the
simplicity of a core idea can be misleading.
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    Identity m >>= f = f m
\end{lstlisting}
#+END_LaTeX
** Proving Left Identity
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}return\ {\tt a} >>= f              \\
 &= {\tt Identity\ a} >>= f
    \tag*{\textbf{defn. {\tt return}}}               \\
 &= f\ {\tt a}
    \tag*{\textbf{defn. {\tt >>=}}}
\end{align*}
** Proving Right Identity
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}{\tt m} >>= return                 \\
 &= {\tt Identity\ m′} >>= return
    \tag*{\textbf{unfold {\tt m}}}                   \\
 &= return\ {\tt m′}
    \tag*{\textbf{defn. {\tt >>=}}}                  \\
 &= {\tt Identity\ m′}
    \tag*{\textbf{defn. {\tt return}}}               \\
 &= {\tt m}
    \tag*{\textbf{fold {\tt m}}}
\end{align*}
** Proving Associativity
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}(m >>= f) >>= g                    \\
 &= ({\tt Identity\ m′} >>= f) >>= g
    \tag*{\textbf{unfold {\tt m}}}                   \\
 &= f\ {\tt m′} >>= g
    \tag*{\textbf{defn. {\tt >>=}}}                  \\
 &= (λx → f\ x >>= g)\ {\tt m′}
    \tag*{\textbf{η-expansion}}                      \\
 &= {\tt Identity\ m′} >>= (λx → f\ x >>= g)
    \tag*{\textbf{defn. {\tt >>=}}}                  \\
 &= m >>= (λx → f\ x >>= g)
    \tag*{\textbf{fold {\tt m}}}
\end{align*}
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    Nothing >>= f = ?
    Just x  >>= f = ?
\end{lstlisting}
#+END_LaTeX
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    Nothing >>= f = Nothing
    Just x  >>= f = Just (f x)
\end{lstlisting}
#+END_LaTeX
** Either                                                                             :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Left e a = Left e | Right a
\end{lstlisting}
#+END_LaTeX
** Tuple                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Pair p a = Pair p a
\end{lstlisting}
#+END_LaTeX
** Const                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
Why can't it be a monad?
* Free Monads
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Free Monads}
* The End
\begin{center}
\includegraphics[width=\linewidth]{images/this-meeting-is-over_3.jpg}
\end{center}
* Colophon

#+STARTUP: beamer
#+STARTUP: content fninline hidestars

#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [utf8x,notes,17pt]

#+BEAMER_THEME: [height=16mm] Rochester
#+BEAMER_COLOR: seahorse

#+OPTIONS:   H:2 toc:nil

#+BEAMER_HEADER: \setbeamertemplate{navigation symbols}{}
#+BEAMER_HEADER: \usepackage{courier}
#+BEAMER_HEADER: \usepackage{helvet}
#+BEAMER_HEADER: \usepackage{listings}
#+BEAMER_HEADER: \usepackage{mathtools}
#+BEAMER_HEADER: \usepackage{pdfcomment}

#+BEAMER_HEADER: \SetUnicodeOption{mathletters}
#+BEAMER_HEADER: \DeclareUnicodeCharacter{952}{\theta}

#+BEAMER_HEADER: \lstset{
#+BEAMER_HEADER:     keywordstyle=\color{blue}
#+BEAMER_HEADER:   , basicstyle=\ttfamily\small
#+BEAMER_HEADER:   , commentstyle={}
#+BEAMER_HEADER:   , columns=fullflexible
#+BEAMER_HEADER:   , showstringspaces=false
#+BEAMER_HEADER:   , keepspaces=true=
#+BEAMER_HEADER:   , breaklines=true
#+BEAMER_HEADER:   , escapeinside={\%*}{*)},
#+BEAMER_HEADER:   }

#+BEAMER_HEADER: \newcommand{\head}[1]{\begin{center}
#+BEAMER_HEADER: \vspace{13mm}\hspace{-1mm}\Huge{{#1}}
#+BEAMER_HEADER: \end{center}}

#+BEAMER_HEADER: \renewcommand{\note}[1]{\marginnote{\pdfcomment[icon=note]{#1}}}

#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+COLUMNS: %20ITEM %13BEAMER_env(Env) %6BEAMER_envargs(Args) %4BEAMER_col(Col) %7BEAMER_extra(Extra)
