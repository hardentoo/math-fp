#+TITLE:  Monads and other abstractions
#+AUTHOR: John Wiegley
#+EMAIL:  johnw@newartisans.com
#+DATE:   4 Jul 2014

#+DESCRIPTION: Applying mathematical abstractions to functional programming
#+KEYWORDS: math monad haskell functional programming
#+LANGUAGE: en

\setbeamertemplate{footline}{}
\setbeamerfont{block body}{size=\small}
\setbeamercolor{bgcolor}{fg=white,bg=blue}

* Mathematics
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Mathematics}
** Meaning
There isn't any.
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
This is just some notes.
** Abstraction
Structures, and relationships between structures.
* Sets
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Sets}
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
What is really interesting is just how much can be done with such a minimal
amount of structure.
** ``Stuff''
A set is a collection of elements.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
type Set a = a -> Bool
\end{lstlisting}
#+END_LaTeX
** Extensional
Can be defined by stating its elements.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
\( \{ \ True, False\ \} \)
** Intensional
Or by describing them.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
\( \{ \ x \ |\  x \in \mathbb{N}, even(x)\ \} \)
** Distinction
Values can be extensionally equal, but intensionally distinct.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
\( n \mapsto 2 (n + 5) \)

\( n \mapsto 2 n + 10 \)
** Deceptively simple
With a basic definition and seven axioms (we've seen two!), you can generate a
good deal of mathematics.
* Functions
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: fram.
:END:
\head{Functions}
** Domain, co-domain, range
[[file:images/Codomain2.pdf]]
** Injective
[[file:images/Mappings1.pdf]]
** Surjective
[[file:images/Mappings2.pdf]]
** Bijective
[[file:images/Mappings3.pdf]]
** Higher-order functions
\[ id\ x = x \]

\[ (f ∘ g)\ x = f (g(x)) \]
** Properties of functions
\[ f : dom → cod \]
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
A powerful concept is to define properties of functions in terms of functions
and equalities.
*** Idempotent                                                                     :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( f ∘ f = f \)
*** Involutive                                                                     :B_definition:
:PROPERTIES:
:BEAMER_act: <3->
:BEAMER_env: definition
:END:
\( f ∘ f = id \)
** Homomorphism
``Structure preserving.''
** Isomorphism
An isomorphism is a pair of functions satisfying two equations:

\[ f ∘ g = id_{cod(f)} \]
\[ g ∘ f = id_{cod(g)} \]
** Isomorphism
In terms of the types involved:

\[ A ≅ B \]

\[ g : A → B \]
\[ f : B → A \]
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Assuming of course \( cod(f) = A, cod(g) = B \).
* Laws
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Laws}
** Imposed structure
In the absence of meaning, laws create structure.
** Principled restriction
Laws restrict how functions and values relate to each other.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Monoid a where
    mempty  :: a
    mappend :: a -> a -> a
\end{lstlisting}
#+END_LaTeX
* Algebras
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Algebras}
* Algebraic Structures
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Algebraic Structures}
** Magmas
** Semigroups
** Monoids
** Groups
* Type Algebras
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Type Algebras}
* Equational Reasoning
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Equational Reasoning}
* Quantification
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Quantification}
** Existential
\[ \exists p, P(p) \]
** Universal
\[ \forall p, P(p) \]
** Universal
*** True?                                                                          :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
\forall x, \exists y \rightarrow x = y
** Universal
*** True?                                                                          :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
\forall x, \exists y \rightarrow x \neq y
* Parametricity
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Parametricity}
* Curry-Howard Isomorphism
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Curry-Howard Isomorphism}
* Free objects
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Free objects}
* Category Theory
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Category Theory}
** Why?
*** Eilenberg and Mac Lane                                                          :B_quotation:
:PROPERTIES:
:BEAMER_env: quotation
:END:
\noindent Their [Eilenberg and Mac Lane's] goal was to understand natural
transformations; in order to do that, functors had to be defined, which
required categories.

-- Wikipedia
* Functors
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Functors}
** Categorical model
[[file:images/Functors1.pdf]]
** String diagram
[[file:images/Functors2.pdf]]
** Unit mapping
[[file:images/Functors3.pdf]]
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
In Haskell, this is called Const.
** Functor laws
*** Functor Law 1                                                                  :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( id = fmap\ id \)
*** Functor Law 2                                                                  :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( fmap\ (f ∘ g) = fmap\ f ∘ fmap\ g \)
** Not containers!
A *Functor* sometimes maps to:
- a container
- a computation
- a type-in-context
\dots{}but a *Functor* /per se/ is none of these.
** Don't be fooled
*Functors* are humble, but powerful.
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    fmap f (Identity x) = ?
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Identity as a concept can be used to implement "taintedness", to force
laziness, to provide singletons, and more.  As should be clear by now, the
simplicity of a core idea can be misleading.
** Proving Identity Law
\fontsize{12}{16}\selectfont
\begin{align*}
id\ {\tt x}             &= fmap\ id\ {\tt x}                      \\
                        &                                         \\
id\ ({\tt Identity\ x}) &= fmap\ id\ ({\tt Identity\ x})
                           \tag*{\textbf{unfold {\tt x}}}         \\
                        &= {\tt Identity}\ (id\ {\tt x})
                           \tag*{\textbf{defn. {\tt fmap}}}       \\
{\tt Identity\ x}       &= {\tt Identity\ x}
                           \tag*{\textbf{defn. {\tt id}}}
\end{align*}
** Proving Composition
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}fmap\ (f ∘ g)\ {\tt x}             \\
 &= fmap\ (f ∘ g)\ ({\tt Identity\ x})
    \tag*{\textbf{unfold {\tt x}}}                   \\
 &= {\tt Identity}\ ((f ∘ g)\ {\tt x})
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= {\tt Identity}\ (f (g ({\tt x})))
    \tag*{\textbf{defn. ∘}}                          \\
 &= fmap\ f\ ({\tt Identity} (g ({\tt x})))
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= fmap\ f\ (fmap\ g\ ({\tt Identity\ x}))
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= fmap\ f\ (fmap\ g\ {\tt x})
    \tag*{\textbf{fold {\tt x}}}
\end{align*}
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    fmap f Nothing  = ?
    fmap f (Just x) = ?
\end{lstlisting}
#+END_LaTeX
** Either                                                                             :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Left e a = Left e | Right a
\end{lstlisting}
#+END_LaTeX
** Tuple                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Pair p a = Pair p a
\end{lstlisting}
#+END_LaTeX
** Const                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Const c a = Const c
\end{lstlisting}
#+END_LaTeX
* Applicatives
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Applicatives}
** Applicative laws
*** 1. Identity Law                                                                :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( pure\ id ⊗ v = v \)
*** 2. Composition Law                                                             :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( pure\ (∘) ⊗ u ⊗ v ⊗ w = u ⊗ (v ⊗ w) \)
*** 3. Homomorphism Law                                                            :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( pure\ f ⊗ pure\ x = pure\ (f(x)) \)
** Applicative laws
*** 4. Interchange Law                                                             :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( u ⊗ pure\ y = pure\ (\$\ y) ⊗ u \)
*** 5. Functor Relation Law                                                        :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( fmap\ f\ x = pure\ f ⊗ x \)
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Applicative Identity where
    pure x = Identity x
    Identity f <*> Identity x = ?
\end{lstlisting}
#+END_LaTeX
** Proving Identity
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}pure\ id ⊗ {\tt v}                 \\
 &= pure\ id ⊗ {\tt Identity\ v}
    \tag*{\textbf{unfold {\tt v}}}                   \\
 &= {\tt Identity}\ id ⊗ {\tt Identity\ v}
    \tag*{\textbf{defn. {\tt pure}}}                 \\
 &= {\tt Identity}\ (id\ {\tt v})
    \tag*{\textbf{defn. ⊗}}                          \\
 &= {\tt Identity\ v}
    \tag*{\textbf{defn. {\tt id}}}                   \\
 &= {\tt v}
    \tag*{\textbf{fold {\tt v}}}
\end{align*}
** Proving Homomorphism
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}pure\ f ⊗ pure\ x                 \\
 &= {\tt Identity}\ f ⊗ {\tt Identity}\ x
    \tag*{\textbf{defn. {\tt pure}}}                 \\
 &= {\tt Identity}\ (f(x))
    \tag*{\textbf{defn. ⊗}}                          \\
 &= pure\ (f(x))
    \tag*{\textbf{defn. {\tt pure}}}
\end{align*}
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    fmap f Nothing  = ?
    fmap f (Just x) = ?
\end{lstlisting}
#+END_LaTeX
** Either                                                                             :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Left e a = Left e | Right a
\end{lstlisting}
#+END_LaTeX
** Tuple                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Pair p a = Pair p a
\end{lstlisting}
#+END_LaTeX
** Const                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Const c a = Const c
\end{lstlisting}
#+END_LaTeX
* Monads
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Monads}
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    fmap f (Identity x) = ?
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Identity as a concept can be used to implement "taintedness", to force
laziness, to provide singletons, and more.  As should be clear by now, the
simplicity of a core idea can be misleading.
** Proving Identity (Law 1)
\fontsize{12}{16}\selectfont
\begin{align*}
id\ {\tt x}             &= fmap\ id\ {\tt x}                      \\
                        &                                         \\
id\ ({\tt Identity\ x}) &= fmap\ id\ ({\tt Identity\ x})
                           \tag*{\textbf{unfold {\tt x}}}         \\
                        &= {\tt Identity}\ (id\ {\tt x})
                           \tag*{\textbf{defn. {\tt fmap}}}       \\
{\tt Identity\ x}       &= {\tt Identity\ x}
                           \tag*{\textbf{defn. {\tt id}}}
\end{align*}
** Proving Homomorphism (Law 3)
\fontsize{12}{16}\selectfont
\begin{align*}
 &  fmap\ (f ∘ g)\ {\tt x}                           \\
 &= fmap\ (f ∘ g)\ ({\tt Identity\ x})
    \tag*{\textbf{unfold {\tt x}}}                   \\
 &= {\tt Identity}\ ((f ∘ g)\ {\tt x})
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= {\tt Identity}\ (f (g ({\tt x})))
    \tag*{\textbf{defn. ∘}}                          \\
 &= fmap\ f\ ({\tt Identity} (g ({\tt x})))
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= fmap\ f\ (fmap\ g\ ({\tt Identity\ x}))
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= fmap\ f\ (fmap\ g\ {\tt x})
    \tag*{\textbf{fold {\tt x}}}
\end{align*}
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    fmap f Nothing  = ?
    fmap f (Just x) = ?
\end{lstlisting}
#+END_LaTeX
** Either                                                                             :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Left e a = Left e | Right a
\end{lstlisting}
#+END_LaTeX
** Tuple                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Pair p a = Pair p a
\end{lstlisting}
#+END_LaTeX
** Const                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Const c a = Const c
\end{lstlisting}
#+END_LaTeX
* Free Monads
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Free Monads}
* Colophon

#+STARTUP: beamer
#+STARTUP: content fninline hidestars

#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [utf8x,notes,17pt]

#+BEAMER_THEME: [height=16mm] Rochester
#+BEAMER_COLOR: seahorse

#+OPTIONS:   H:2 toc:nil

#+BEAMER_HEADER: \setbeamertemplate{navigation symbols}{}
#+BEAMER_HEADER: \usepackage{courier}
#+BEAMER_HEADER: \usepackage{helvet}
#+BEAMER_HEADER: \usepackage{listings}
#+BEAMER_HEADER: \usepackage{mathtools}
#+BEAMER_HEADER: \usepackage{pdfcomment}

#+BEAMER_HEADER: \SetUnicodeOption{mathletters}
#+BEAMER_HEADER: \DeclareUnicodeCharacter{952}{\theta}

#+BEAMER_HEADER: \lstset{
#+BEAMER_HEADER:     keywordstyle=\color{blue}
#+BEAMER_HEADER:   , basicstyle=\ttfamily\small
#+BEAMER_HEADER:   , commentstyle={}
#+BEAMER_HEADER:   , columns=fullflexible
#+BEAMER_HEADER:   , showstringspaces=false
#+BEAMER_HEADER:   , keepspaces=true=
#+BEAMER_HEADER:   , breaklines=true
#+BEAMER_HEADER:   }

#+BEAMER_HEADER: \newcommand{\head}[1]{\begin{center}
#+BEAMER_HEADER: \vspace{13mm}\hspace{-1mm}\Huge{{#1}}
#+BEAMER_HEADER: \end{center}}

#+BEAMER_HEADER: \renewcommand{\note}[1]{\marginnote{\pdfcomment[icon=note]{#1}}}

#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+COLUMNS: %20ITEM %13BEAMER_env(Env) %6BEAMER_envargs(Args) %4BEAMER_col(Col) %7BEAMER_extra(Extra)
