#+TITLE:  Monads and other abstractions
#+AUTHOR: John Wiegley
#+EMAIL:  johnw@newartisans.com
#+DATE:   4 Jul 2014

#+DESCRIPTION: Applying mathematical abstractions to functional programming
#+KEYWORDS: math monad haskell functional programming
#+LANGUAGE: en

\setbeamertemplate{footline}{}
\setbeamerfont{block body}{size=\small}
\setbeamercolor{bgcolor}{fg=white,bg=blue}

* Mathematics
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Mathematics}
** Meaning
There isn't any.
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
This is just some notes.
** Abstraction
Structures, and relationships between structures.
* Sets
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Sets}
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
What is really interesting is just how much can be done with such a minimal
amount of structure.
** ``Stuff''
A set is a collection of elements.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
type Set a = a -> Bool
\end{lstlisting}
#+END_LaTeX
** Extensional
Can be defined by stating its elements.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
\( \{ \ True, False\ \} \)
** Intensional
Or by describing them.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
\( \{ \ x \ |\  x \in \mathbb{N}, even(x)\ \} \)
** Distinction
Values can be extensionally equal, but intensionally distinct.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
\( n \mapsto 2 (n + 5) \)

\( n \mapsto 2 n + 10 \)
** Deceptively simple
With just a basic definition, and seven axioms (we've already seen two!), you
can generate a good deal of mathematics.
* Functions
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: fram.
:END:
\head{Functions}
** As maps
:PROPERTIES:
:BEAMER_act: <1>
:END:
#+begin_src ditaa :file images/maps.png :cmdline "-s 2.5"
+-----+   +------+
| {o} |   | {o}  |
|  x  |-->| f(x) |
|  y  |-->| f(y) |
|  z  |-->| f(z) |
|     |   |      |
+-----+   +------+
#+end_src

#+RESULTS:
[[file:images/maps.png]]
** Domain, range, image
[[file:images/Codomain2.png]]
** Higher-order functions
\[ id\ x = x \]

\[ (f ∘ g)\ x = f (g(x)) \]
** Properties of functions
\[ f : dom → cod \]
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
A powerful concept is to define properties of functions in terms of functions
and equalities.
*** Idempotent                                                                     :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( f ∘ f = f \)
*** Involutive                                                                     :B_definition:
:PROPERTIES:
:BEAMER_act: <3->
:BEAMER_env: definition
:END:
\( f ∘ f = id \)
** Homomorphism
``Structure preserving.''
** Isomorphism
An isomorphism is a pair of functions satisfying two equations:

\[ f ∘ g = id_{cod(f)} \]
\[ g ∘ f = id_{cod(g)} \]
** Isomorphism
In terms of the types involved:

\[ A ≅ B \]

\[ g : A → B \]
\[ f : B → A \]
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Assuming of course \( cod(f) = A, cod(g) = B \).
* Laws
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Laws}
** Imposed structure
In the absence of meaning, laws create structure.
** Principled restriction
Laws restrict how functions and values relate to each other.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Monoid a where
    mempty  :: a
    mappend :: a -> a -> a
\end{lstlisting}
#+END_LaTeX
* Algebras
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Algebras}
* Algebraic Structures
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Algebraic Structures}
** Magmas
** Semigroups
** Monoids
** Groups
* Type Algebras
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Type Algebras}
* Equational Reasoning
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Equational Reasoning}
* Quantification
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Quantification}
** Existential
\[ \exists p, P(p) \]
** Universal
\[ \forall p, P(p) \]
** Universal
*** True?                                                                          :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
\forall x, \exists y \rightarrow x = y
** Universal
*** True?                                                                          :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
\forall x, \exists y \rightarrow x \neq y
* Parametricity
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Parametricity}
* Curry-Howard Isomorphism
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Curry-Howard Isomorphism}
* Free objects
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Free objects}
* Category Theory
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Category Theory}
* Functors
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Functors}
* Applicatives
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Applicatives}
* Monads
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Monads}
* Free Monads
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Free Monads}
* Colophon

#+STARTUP: beamer
#+STARTUP: content fninline hidestars

#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [utf8x,notes,17pt]

#+BEAMER_THEME: [height=16mm] Rochester
#+BEAMER_COLOR: seahorse

#+OPTIONS:   H:2 toc:nil

#+BEAMER_HEADER: \setbeamertemplate{navigation symbols}{}
#+BEAMER_HEADER: \usepackage{courier}
#+BEAMER_HEADER: \usepackage{helvet}
#+BEAMER_HEADER: \usepackage{listings}
#+BEAMER_HEADER: \usepackage{pdfcomment}

#+BEAMER_HEADER: \SetUnicodeOption{mathletters}
#+BEAMER_HEADER: \DeclareUnicodeCharacter{952}{\theta}

#+BEAMER_HEADER: \lstset{
#+BEAMER_HEADER:     keywordstyle=\color{blue}
#+BEAMER_HEADER:   , basicstyle=\ttfamily\small
#+BEAMER_HEADER:   , commentstyle={}
#+BEAMER_HEADER:   , columns=fullflexible
#+BEAMER_HEADER:   , showstringspaces=false
#+BEAMER_HEADER:   , keepspaces=true=
#+BEAMER_HEADER:   , breaklines=true
#+BEAMER_HEADER:   }

#+BEAMER_HEADER: \newcommand{\head}[1]{\begin{center}
#+BEAMER_HEADER: \vspace{13mm}\hspace{-1mm}\Huge{{#1}}
#+BEAMER_HEADER: \end{center}}

#+BEAMER_HEADER: \renewcommand{\note}[1]{\marginnote{\pdfcomment[icon=note]{#1}}}

#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+COLUMNS: %20ITEM %13BEAMER_env(Env) %6BEAMER_envargs(Args) %4BEAMER_col(Col) %7BEAMER_extra(Extra)
