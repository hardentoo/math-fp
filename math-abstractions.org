#+TITLE:  Monads and other abstractions
#+AUTHOR: John Wiegley
#+EMAIL:  johnw@newartisans.com
#+DATE:   4 Jul 2014

#+DESCRIPTION: Applying mathematical abstractions to functional programming
#+KEYWORDS: math monad haskell functional programming
#+LANGUAGE: en

\setbeamertemplate{footline}{}
\setbeamerfont{block body}{size=\small}
\definecolor{orchid}{RGB}{134, 134, 220}
\setbeamercolor{block title}{fg=white,bg=orchid}
\setbeamercolor{bgcolor}{fg=white,bg=blue}

* Overview
** Workshop overview
1. Basic math definitions
2. Algebras and laws
3. Working with proofs
4. Category theory & Functors
5. Monads
* Mathematics
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Mathematics}
** Meaning
There isn't any.
** Abstraction
Structures, and relationships between structures.
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Math is really a language, a whole system, for talking about structures and
their relationships.  Meaning and abstraction form a kind of tension, since
you move away from meaning into abstraction, and to gain meaning you must give
up abstraction.
* Sets
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Sets}
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
What is really interesting is just how much can be done with such a minimal
amount of structure.
** ``Stuff''
\begin{center}
\includegraphics[width=.65\linewidth]{images/Sets1.pdf}
\end{center}
** ``Stuff''
\begin{center}
\includegraphics[width=.65\linewidth]{images/Sets2.pdf}
\end{center}
** Sets of sets
\begin{center}
\includegraphics[width=.65\linewidth]{images/Sets3.pdf}
\end{center}
** Extensional
Can be defined by stating its elements.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
\( \{ \ True, False\ \} \)
** Intensional
Or by describing them.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
\( \{ \ x \ |\  x \in \mathbb{N}, even(x)\ \} \)
** Programmatic
Can be modeled programmatically.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
type Set a = a -> Bool

import Data.Set as S
type Set a = S.Set a
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
This introduces the idea of modeling constructs as functions instead of data
structures.
** Exercise
Using the functional definition of sets, define union and intersection.
*** \vspace*{-3.5ex}                                                               :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
type Set a = a -> Bool

union :: Set a -> Set a -> Set a
inter :: Set a -> Set a -> Set a
\end{lstlisting}
#+END_LaTeX
** Deceptively simple
With a basic definition and seven axioms (we've seen two!), you can generate a
good deal of mathematics.
* Functions
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: fram.
:END:
\head{Functions}
** Domain, co-domain, range
\begin{center}
\includegraphics[width=.9\linewidth]{images/Codomain2.pdf}
\end{center}
** Injective
\begin{center}
\includegraphics[width=.9\linewidth]{images/Mappings1.pdf}
\end{center}
** Injective
\[ f : A → B \]

\[ ∀ x, y ∈ A \]

\[ f\ x = f\ y → x = y \]
** Injective
Examples of injective things:

- Data constructors
- Type constructors
- But not type synonyms\dots{}
** Exercise
1. Write an injective functions on integer, and one that is not injective.

2. How do you test it in both cases?
** Surjective
\begin{center}
\includegraphics[width=.9\linewidth]{images/Mappings2.pdf}
\end{center}
** Surjective
\[ f : A → B \]

\[ ∀ y ∈ B, ∃ x ∈ A \]

\[ f\ x = y \]
** Surjective
A function is surjective if the set of possible results is not a subset of its
type.  Example:

- \texttt{even} is surjective
- \texttt{times2} is not
** Bijective
\begin{center}
\includegraphics[width=.9\linewidth]{images/Mappings3.pdf}
\end{center}
** Higher-order functions
*** Identity                                                                       :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( id\ x = x \)
*** Composition                                                                    :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( (f ∘ g)\ x = f (g(x)) \)
** Properties of functions
\[ f : dom → cod \]
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
A powerful concept is to define properties of functions in terms of functions
and equalities.
*** Idempotent                                                                     :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( f ∘ f = f \)
*** Involutive                                                                     :B_definition:
:PROPERTIES:
:BEAMER_act: <3->
:BEAMER_env: definition
:END:
\( f ∘ f = id \)
** More properties
*** Section                                                                        :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( f ∘ s = id \)
*** Retract                                                                        :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( r ∘ f = id \)
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
I only mention these to show how much structures we can infer from a very
small set of building blocks.
** Exercise
For the set of integers, show examples of:

1. idempotency
2. involution
3. section
4. retraction
** Isomorphism
An isomorphism is a pair of functions satisfying two equations:

\[ f ∘ g = id_{cod(f)} \]
\[ g ∘ f = id_{cod(g)} \]
** Isomorphism
In terms of the types involved:

\[ A ≅ B \]

\[ g : A → B \]
\[ f : B → A \]
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Assuming of course \( cod(f) = A, cod(g) = B \).
** Exercise
\vspace{-2ex}
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Unit = Unit
data Maybe a = Nothing | Just a

toMaybe :: Integer -> Maybe Unit
fromMaybe :: Maybe Unit -> Integer
\end{lstlisting}
#+END_LaTeX
*** True?                                                                          :B_alertblock:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: alertblock
:END:
\texttt{Maybe Unit}\hspace{1em}≅\hspace{1em}\texttt{Integer}
* Laws
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Laws}
** Imposed structure
In the absence of meaning, laws create structure.
** Principled restriction
Laws restrict how functions and values relate to each other.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Monoid a where
    mempty  :: a
    mappend :: a -> a -> a
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Give the example of why mempty from Monoid is good, but point from Pointed is
not.
** Associativity
\[ x • (y • z) = (x • y) • z \]
** Commutativity
\[ x • y = y • x \]
** Transitivity
\[ x • y → y • z → x • z \]
* [Break]
** [Break]
\begin{center}
\includegraphics[width=.9\linewidth]{images/flip-concatmap.jpg}
\end{center}
* Algebras
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Algebras}
** Sets with structure
Algebras are basically:
- a set (called the /carrier/)
- functions closed over the set
- laws to govern these functions
** Named structures
Some structures recur often enough that it's useful to name them, but the
names are arbitrary.
** Magma
\[ (S, s → s → s) \]

\vspace{2em}
The set of laws is empty!
** Magma
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Magma a where
    binop :: a -> a -> a

instance Magma Integer where
    binop = (+)
\end{lstlisting}
#+END_LaTeX
** Semigroup
\[ (S, s → s → s) \]

Laws:

1. associativity
** Semigroup
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Semigroup a where
    (<>) :: a -> a -> a
\end{lstlisting}
#+END_LaTeX
*** Semigroup law
:PROPERTIES:
:BEAMER_act: <2->
:END:
\vspace{-3.5ex}
\begin{align*}
a ⊕ (b ⊕ c) &= (a ⊕ b) ⊕ c
\end{align*}
** Monoid
\[ (S, ε, s → s → s) \]

Laws:

1. left identity
2. right identity
3. associativity
** Monoid
\vspace{-2ex}
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Monoid a where
    mempty  :: a
    mappend :: a -> a -> a
\end{lstlisting}
#+END_LaTeX
*** Monoid laws                                                                    :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:END:
\vspace{-3.5ex}
\begin{align*}
ε ⊕ a &= a \\
a ⊕ ε &= a \\
a ⊕ (b ⊕ c) &= (a ⊕ b) ⊕ c
\end{align*}
** Group
\[ (S, ε, s → s → s, s → s) \]

Laws:

1. left identity
2. right identity
3. associativity
4. inverse elements
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Note that the only difference here is in the laws, not the operations.
** Group
*** Group laws
\vspace{-3.5ex}
\begin{align*}
ε ⊕ a &= a \\
a ⊕ ε &= a \\
a ⊕ (b ⊕ c) &= (a ⊕ b) ⊕ c \\
a ⊕ a^{-1} &= ε
\end{align*}
** Homomorphism
``Structure preserving.''
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
floor :: Float -> Int
\end{lstlisting}
#+END_LaTeX
** Free objects
What if our monoid, instead of /doing something/, only constructed values?
** Free objects
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data MV a = MEmpty
          | Var a
          | MAppend (MV a) (MV a)

instance Monoid (MV a) where
    mempty  = MEmpty
    mappend = MAppend 
\end{lstlisting}
#+END_LaTeX
** Building trees
\[ (a ⊕ b) ⊕ c ⊕ (d ⊕ e) \]
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
 (Var a `MAppend` Var b)
   `MAppend`
 Var c
   `MAppend`
 (Var d `MAppend` Var e)
\end{lstlisting}
#+END_LaTeX
** Using the laws
Due to the law of associativity, calls to \texttt{mappend} can always be
re-associated:

\[ a ⊕ (b ⊕ (c ⊕ (d ⊕ e))) \]
** Using the laws
This changes the expression into something linear, rather than a tree:
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
 Var a `MAppend`
 (Var b `MAppend`
  (Var c `MAppend`
   (Var d `MAppend`
    (Var e `MAppend` MEmpty))))
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
This structure should look familiar...
** Using the laws
Relying on this law, we can simplify the data type:
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data MV a = MEmpty
          | MAppend a (MV a)
\end{lstlisting}
#+END_LaTeX
** Using the laws
But let's rename the constructors to something more familiar:
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data List a = Nil
            | Cons a (List a)
\end{lstlisting}
#+END_LaTeX
** Data structures
Free objects of an algebra become data structures in programming.
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Free semigroups are non-empty lists.  Free groups are lists that allow members
to be removed by appending an inverse value.
** Folding
Choosing operations for an algebra is equivalent to folding over its free
object.
** Evaluators
The two essential aspects of an algebra are:

- Forming expressions
- Evaluating these expressions
** Free functors
Every free object is trivially a functor, called a free functor.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
instance Functor List where
    fmap _ Nil = Nil
    fmap f (Cons x xs)
        = Cons (f x) (fmap f xs)
\end{lstlisting}
#+END_LaTeX
** F-algebras
We can encode algebras using functions and free functors:
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
type Algebra f a = f a -> a

sum :: Algebra List Int
sum Nil = 0
sum (Cons x xs) = x + sum xs
\end{lstlisting}
#+END_LaTeX
** Recursion schemes
We won't cover it, but the recursion can be abstracted away for an even more
general form: \\
\vspace{1ex}
\fontsize{14}{11}\selectfont
https://www.fpcomplete.com/user/bartosz/understanding-algebras
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
This can have speed benefits by improving optimization opportunities, and can
make otherwise recursive algorithms much simpler to write.
* [Break]
** [Break]
\begin{center}
\includegraphics[width=.9\linewidth]{images/tail-recursion.jpg}
\end{center}
* Equational Reasoning
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Equational Reasoning}
** Working with proofs
Equational reasoning gives us a way to reason about pure computations.
** Basic format
\begin{align*}
x  &= y                      \\
   &= y'  \tag*{reason}      \\
   &= y'' \tag*{reason}      \\
   &= x   \tag*{reason}
\end{align*}
* Quantification
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Quantification}
** Existential
\[ \exists p, P(p) \]
** Universal
\[ \forall p, P(p) \]
** Universal
*** True?                                                                          :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
\forall x, \exists y \rightarrow x = y
** Universal
*** True?                                                                          :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
\forall x, \exists y \rightarrow x \neq y
* Parametricity
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Parametricity}
** Free theorems
What does the following type imply (assuming no ⊥)?
\vspace{1.5ex}
*** filter                                                                            :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
filter :: (a -> Bool) -> [a] -> [a]
filter f xs = _
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
There's a law that I will not be able to violate when writing this function.
It is "proven by construction".
** Free theorems
*** filter                                                                            :B_theorem:
:PROPERTIES:
:BEAMER_env: theorem
:END:
\vspace{1ex}
\( ∀ g : a → b \) \\
\vspace{1ex}
\( ∀ p : a → {\tt Bool} \)

\( ∀ q : b → {\tt Bool} \)
\begin{flalign*}
∀ x, p\ x = q\ (g\ x) ⟶ & \\
  \vspace{1ex}\hspace{2em}map\ g\ (\textbf{filter}\ p\ xs)
    &= \textbf{filter}\ q\ (map\ g\ xs) &
\end{flalign*}
** Free theorem generator
Automatically generate free theorems for sub-languages of Haskell: \\
\vspace{1ex}
\fontsize{14}{11}\selectfont
http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Sub-languages include: no bottoms (hence no general recursion and no selective
strictness); general recursion but no selective strictness; general recursion
and selective strictness.
* Curry-Howard Isomorphism
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Curry-Howard Isomorphism}
* [Break]
** [Break]
\begin{center}
\includegraphics[width=.9\linewidth]{images/hascat.jpg}
\end{center}
* Category Theory
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Category Theory}
** Sets with structure
\begin{center}
\includegraphics[width=.65\linewidth]{images/Category1.pdf}
\end{center}
* Functors
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Functors}
** Categorical model
\begin{center}
\includegraphics[width=.9\linewidth]{images/Functors1.pdf}
\end{center}
** Unit mapping
\begin{center}
\includegraphics[width=.9\linewidth]{images/Functors2.pdf}
\end{center}
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
In Haskell, this is called Const.
** Functor laws
*** 1. Identity law                                                                :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( fmap\ id = id \)
*** 2. Composition law                                                             :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( fmap\ (f ∘ g) = fmap\ f ∘ fmap\ g \)
** Not containers!
A *Functor* sometimes maps to:
- a container
- a computation
\dots{}but a *Functor* /per se/ is neither.
** As Context
:PROPERTIES:
:BEAMER_env: frame
:END:
\fontsize{42}{36}\selectfont
\[ \textbf{F}\ {\tt a} \]
** Don't be fooled
*Functors* are humble, but powerful.
** Origins
*** Eilenberg and Mac Lane                                                          :B_quotation:
:PROPERTIES:
:BEAMER_env: quotation
:END:
\noindent Their [Eilenberg and Mac Lane's] goal was to understand natural
transformations; in order to do that, functors had to be defined, which
required categories.

-- Wikipedia
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    fmap f (Identity x) = ?
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Identity as a concept can be used to implement "taintedness", to force
laziness, to provide singletons, and more.  As should be clear by now, the
simplicity of a core idea can be misleading.
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    fmap f (Identity x) = Identity (f x)
\end{lstlisting}
#+END_LaTeX
** Proving Identity Law
\fontsize{12}{16}\selectfont
\begin{align*}
id\ {\tt x}              &= fmap\ id\ {\tt x}                      \\
                         &                                         \\
id\ ({\tt Identity\ x′}) &= fmap\ id\ ({\tt Identity\ x′})
                            \tag*{\textbf{unfold {\tt x}}}         \\
                         &= {\tt Identity}\ (id\ {\tt x′})
                            \tag*{\textbf{defn. {\tt fmap}}}       \\
{\tt Identity\ x′}       &= {\tt Identity\ x′}
                            \tag*{\textbf{defn. {\tt id}}}
\end{align*}
** Proving Composition
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}fmap\ (f ∘ g)\ {\tt x}             \\
 &= fmap\ (f ∘ g)\ ({\tt Identity\ x′})
    \tag*{\textbf{unfold {\tt x}}}                   \\
 &= {\tt Identity}\ ((f ∘ g)\ {\tt x′})
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= {\tt Identity}\ (f (g ({\tt x′})))
    \tag*{\textbf{defn. ∘}}                          \\
 &= fmap\ f\ ({\tt Identity} (g ({\tt x′})))
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= fmap\ f\ (fmap\ g\ ({\tt Identity\ x′}))
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= fmap\ f\ (fmap\ g\ {\tt x})
    \tag*{\textbf{fold {\tt x}}}
\end{align*}
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    fmap f Nothing  = ?
    fmap f (Just x) = ?
\end{lstlisting}
#+END_LaTeX
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    fmap f Nothing  = Nothing
    fmap f (Just x) = Just (f x)
\end{lstlisting}
#+END_LaTeX
** Either                                                                             :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Left e a = Left e | Right a
\end{lstlisting}
#+END_LaTeX
** Tuple                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Pair p a = Pair p a
\end{lstlisting}
#+END_LaTeX
** Const                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Const c a = Const c
\end{lstlisting}
#+END_LaTeX
* Applicatives
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Applicatives}
** Applicative laws
*** 1. Identity law                                                                :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( pure\ id ⊗ v = v \)
*** 2. Composition law                                                             :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( pure\ (∘) ⊗ u ⊗ v ⊗ w = u ⊗ (v ⊗ w) \)
*** 3. Homomorphism law                                                            :B_definition:
:PROPERTIES:
:BEAMER_act: <3->
:BEAMER_env: definition
:END:
\( pure\ f ⊗ pure\ x = pure\ (f(x)) \)
** Applicative laws
*** 4. Interchange law                                                             :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( u ⊗ pure\ y = pure\ (\$\ y) ⊗ u \)
*** 5. Functor relation law                                                        :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( fmap\ f\ x = pure\ f ⊗ x \)
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Applicative Identity where
    pure x = Identity x
    Identity f <*> Identity x = ?
\end{lstlisting}
#+END_LaTeX
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Applicative Identity where
    pure x = Identity x
    Identity f <*> Identity x = Identity (f x)
\end{lstlisting}
#+END_LaTeX
** Proving Identity
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}pure\ id ⊗ {\tt v}                 \\
 &= pure\ id ⊗ {\tt Identity\ v}
    \tag*{\textbf{unfold {\tt v}}}                   \\
 &= {\tt Identity}\ id ⊗ {\tt Identity\ v}
    \tag*{\textbf{defn. {\tt pure}}}                 \\
 &= {\tt Identity}\ (id\ {\tt v})
    \tag*{\textbf{defn. ⊗}}                          \\
 &= {\tt Identity\ v}
    \tag*{\textbf{defn. {\tt id}}}                   \\
 &= {\tt v}
    \tag*{\textbf{fold {\tt v}}}
\end{align*}
** Proving Homomorphism
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}pure\ f ⊗ pure\ x                 \\
 &= {\tt Identity}\ f ⊗ {\tt Identity}\ x
    \tag*{\textbf{defn. {\tt pure}}}                 \\
 &= {\tt Identity}\ (f(x))
    \tag*{\textbf{defn. ⊗}}                          \\
 &= pure\ (f(x))
    \tag*{\textbf{defn. {\tt pure}}}
\end{align*}
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Applicative Maybe where
    pure x = ?

    Nothing <*> Nothing = ?
    Just f  <*> Nothing = ?
    Nothing <*> Just x  = ?
    Just f  <*> Just x  = ?
\end{lstlisting}
#+END_LaTeX
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Applicative Maybe where
    pure x = ?

    Just f <*> Just x = Just (f x)
    _      <*> _      = Nothing
\end{lstlisting}
#+END_LaTeX
** Either                                                                             :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Left e a = Left e | Right a
\end{lstlisting}
#+END_LaTeX
** Tuple                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Pair p a = Pair p a
\end{lstlisting}
#+END_LaTeX
** Const                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
**Const** requires a trickier instance.
\vspace{1.5ex}
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Const c a = Const c

instance Monoid c
    => Applicative (Const c) where
    pure x = ?
    Const a <*> Const b = ?
\end{lstlisting}
#+END_LaTeX
* [Break]
** [Break]
\begin{center}
\includegraphics[width=.9\linewidth]{images/monad-tutorial.jpg}
\end{center}
* Monads
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Monads}
** Two formulations
*** Using bind                                                                     :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
return :: m a
(>>=)  :: m a -> (a -> m b) -> m b
\end{lstlisting}
#+END_LaTeX
*** Using join                                                                     :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
return :: m a
join   :: m (m a) -> m a
\end{lstlisting}
#+END_LaTeX
** Bind in terms of join                                                           :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
m >>= f = join (fmap f m)
\end{lstlisting}
#+END_LaTeX
** Monad laws
*** 1. Left identity law                                                           :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( return\ a >>= f = f a \)
*** 2. Right identity Law                                                          :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( m >>= return = m \)
*** 3. Associativity Law                                                           :B_definition:
:PROPERTIES:
:BEAMER_act: <3->
:BEAMER_env: definition
:END:
\( (m >>= f) >>= g = m >>= (λx → f\ x >>= g) \)
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    Identity m >>= f = ?
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Identity as a concept can be used to implement "taintedness", to force
laziness, to provide singletons, and more.  As should be clear by now, the
simplicity of a core idea can be misleading.
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    Identity m >>= f = f m
\end{lstlisting}
#+END_LaTeX
** Proving Left Identity
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}return\ {\tt a} >>= f              \\
 &= {\tt Identity\ a} >>= f
    \tag*{\textbf{defn. {\tt return}}}               \\
 &= f\ {\tt a}
    \tag*{\textbf{defn. {\tt >>=}}}
\end{align*}
** Proving Right Identity
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}{\tt m} >>= return                 \\
 &= {\tt Identity\ m′} >>= return
    \tag*{\textbf{unfold {\tt m}}}                   \\
 &= return\ {\tt m′}
    \tag*{\textbf{defn. {\tt >>=}}}                  \\
 &= {\tt Identity\ m′}
    \tag*{\textbf{defn. {\tt return}}}               \\
 &= {\tt m}
    \tag*{\textbf{fold {\tt m}}}
\end{align*}
** Proving Associativity
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}(m >>= f) >>= g                    \\
 &= ({\tt Identity\ m′} >>= f) >>= g
    \tag*{\textbf{unfold {\tt m}}}                   \\
 &= f\ {\tt m′} >>= g
    \tag*{\textbf{defn. {\tt >>=}}}                  \\
 &= (λx → f\ x >>= g)\ {\tt m′}
    \tag*{\textbf{η-expansion}}                      \\
 &= {\tt Identity\ m′} >>= (\textbackslash x → f\ x >>= g)
    \tag*{\textbf{defn. {\tt >>=}}}                  \\
 &= m >>= (λx → f\ x >>= g)
    \tag*{\textbf{fold {\tt m}}}
\end{align*}
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    Nothing >>= f = ?
    Just x  >>= f = ?
\end{lstlisting}
#+END_LaTeX
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    Nothing >>= f = Nothing
    Just x  >>= f = Just (f x)
\end{lstlisting}
#+END_LaTeX
** Either                                                                             :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Left e a = Left e | Right a
\end{lstlisting}
#+END_LaTeX
** Tuple                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Pair p a = Pair p a
\end{lstlisting}
#+END_LaTeX
** Const                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
Why can't it be a monad?
* Free Monads
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Free Monads}
* Colophon

#+STARTUP: beamer
#+STARTUP: content fninline hidestars

#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [utf8x,notes,17pt]

#+BEAMER_THEME: [height=16mm] Rochester
#+BEAMER_COLOR: seahorse

#+OPTIONS:   H:2 toc:nil

#+BEAMER_HEADER: \setbeamertemplate{navigation symbols}{}
#+BEAMER_HEADER: \usepackage{courier}
#+BEAMER_HEADER: \usepackage{helvet}
#+BEAMER_HEADER: \usepackage{listings}
#+BEAMER_HEADER: \usepackage{mathtools}
#+BEAMER_HEADER: \usepackage{pdfcomment}

#+BEAMER_HEADER: \SetUnicodeOption{mathletters}
#+BEAMER_HEADER: \DeclareUnicodeCharacter{952}{\theta}

#+BEAMER_HEADER: \lstset{
#+BEAMER_HEADER:     keywordstyle=\color{blue}
#+BEAMER_HEADER:   , basicstyle=\ttfamily\small
#+BEAMER_HEADER:   , commentstyle={}
#+BEAMER_HEADER:   , columns=fullflexible
#+BEAMER_HEADER:   , showstringspaces=false
#+BEAMER_HEADER:   , keepspaces=true=
#+BEAMER_HEADER:   , breaklines=true
#+BEAMER_HEADER:   , escapeinside={\%*}{*)},
#+BEAMER_HEADER:   }

#+BEAMER_HEADER: \newcommand{\head}[1]{\begin{center}
#+BEAMER_HEADER: \vspace{13mm}\hspace{-1mm}\Huge{{#1}}
#+BEAMER_HEADER: \end{center}}

#+BEAMER_HEADER: \renewcommand{\note}[1]{\marginnote{\pdfcomment[icon=note]{#1}}}

#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+COLUMNS: %20ITEM %13BEAMER_env(Env) %6BEAMER_envargs(Args) %4BEAMER_col(Col) %7BEAMER_extra(Extra)
