#+TITLE:  Monads and other abstractions
#+AUTHOR: John Wiegley
#+EMAIL:  johnw@newartisans.com
#+DATE:   4 Jul 2014

#+DESCRIPTION: Applying mathematical abstractions to functional programming
#+KEYWORDS: math monad haskell functional programming
#+LANGUAGE: en

\setbeamertemplate{footline}{}
\setbeamerfont{block body}{size=\small}
\definecolor{orchid}{RGB}{134, 134, 220}
\setbeamercolor{block title}{fg=white,bg=orchid}
\setbeamercolor{bgcolor}{fg=white,bg=blue}

* Mathematics
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Mathematics}
** Meaning
There isn't any.
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
This is just some notes.
** Abstraction
Structures, and relationships between structures.
* Sets
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Sets}
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
What is really interesting is just how much can be done with such a minimal
amount of structure.
** ``Stuff''
A set is a collection of elements.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
type Set a = a -> Bool
\end{lstlisting}
#+END_LaTeX
** Extensional
Can be defined by stating its elements.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
\( \{ \ True, False\ \} \)
** Intensional
Or by describing them.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
\( \{ \ x \ |\  x \in \mathbb{N}, even(x)\ \} \)
** Distinction
Values can be extensionally equal, but intensionally distinct.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
\( n \mapsto 2 (n + 5) \)

\( n \mapsto 2 n + 10 \)
** Deceptively simple
With a basic definition and seven axioms (we've seen two!), you can generate a
good deal of mathematics.
* Functions
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: fram.
:END:
\head{Functions}
** Domain, co-domain, range
[[file:images/Codomain2.pdf]]
** Injective
[[file:images/Mappings1.pdf]]
** Surjective
[[file:images/Mappings2.pdf]]
** Bijective
[[file:images/Mappings3.pdf]]
** Higher-order functions
*** Identity                                                                       :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( id\ x = x \)
*** Composition                                                                    :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( (f ∘ g)\ x = f (g(x)) \)
** Properties of functions
\[ f : dom → cod \]
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
A powerful concept is to define properties of functions in terms of functions
and equalities.
*** Idempotent                                                                     :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( f ∘ f = f \)
*** Involutive                                                                     :B_definition:
:PROPERTIES:
:BEAMER_act: <3->
:BEAMER_env: definition
:END:
\( f ∘ f = id \)
** More properties
*** Section                                                                        :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( f ∘ s = id \)
*** Retract                                                                        :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( r ∘ f = id \)
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
I only mention these to show how much structures we can infer from a very
small set of building blocks.
** Isomorphism
An isomorphism is a pair of functions satisfying two equations:

\[ f ∘ g = id_{cod(f)} \]
\[ g ∘ f = id_{cod(g)} \]
** Isomorphism
In terms of the types involved:

\[ A ≅ B \]

\[ g : A → B \]
\[ f : B → A \]
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Assuming of course \( cod(f) = A, cod(g) = B \).
* Laws
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Laws}
** Imposed structure
In the absence of meaning, laws create structure.
** Principled restriction
Laws restrict how functions and values relate to each other.
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
class Monoid a where
    mempty  :: a
    mappend :: a -> a -> a
\end{lstlisting}
#+END_LaTeX
* Algebras
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Algebras}
* Algebraic Structures
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Algebraic Structures}
** Magmas
** Semigroups
** Monoids
** Groups
** Homomorphism
``Structure preserving.''
* Type Algebras
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Type Algebras}
* Equational Reasoning
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Equational Reasoning}
* Quantification
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Quantification}
** Existential
\[ \exists p, P(p) \]
** Universal
\[ \forall p, P(p) \]
** Universal
*** True?                                                                          :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
\forall x, \exists y \rightarrow x = y
** Universal
*** True?                                                                          :B_alertblock:
:PROPERTIES:
:BEAMER_env: alertblock
:END:
\forall x, \exists y \rightarrow x \neq y
* Parametricity
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Parametricity}
* Curry-Howard Isomorphism
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Curry-Howard Isomorphism}
* Free objects
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Free objects}
* Category Theory
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Category Theory}
** Why?
*** Eilenberg and Mac Lane                                                          :B_quotation:
:PROPERTIES:
:BEAMER_env: quotation
:END:
\noindent Their [Eilenberg and Mac Lane's] goal was to understand natural
transformations; in order to do that, functors had to be defined, which
required categories.

-- Wikipedia
* Functors
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Functors}
** Categorical model
[[file:images/Functors1.pdf]]
** String diagram
[[file:images/Functors2.pdf]]
** Unit mapping
[[file:images/Functors3.pdf]]
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
In Haskell, this is called Const.
** Functor laws
*** 1. Identity law                                                                :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( id = fmap\ id \)
*** 2. Composition law                                                             :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( fmap\ (f ∘ g) = fmap\ f ∘ fmap\ g \)
** Not containers!
A *Functor* sometimes maps to:
- a container
- a computation
\dots{}but a *Functor* /per se/ is neither.
** As Context
\head{\( \textbf{F}\ {\tt a} \)}
** Don't be fooled
*Functors* are humble, but powerful.
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    fmap f (Identity x) = ?
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Identity as a concept can be used to implement "taintedness", to force
laziness, to provide singletons, and more.  As should be clear by now, the
simplicity of a core idea can be misleading.
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    fmap f (Identity x) = Identity (f x)
\end{lstlisting}
#+END_LaTeX
** Proving Identity Law
\fontsize{12}{16}\selectfont
\begin{align*}
id\ {\tt x}              &= fmap\ id\ {\tt x}                      \\
                         &                                         \\
id\ ({\tt Identity\ x′}) &= fmap\ id\ ({\tt Identity\ x′})
                            \tag*{\textbf{unfold {\tt x}}}         \\
                         &= {\tt Identity}\ (id\ {\tt x′})
                            \tag*{\textbf{defn. {\tt fmap}}}       \\
{\tt Identity\ x′}       &= {\tt Identity\ x′}
                            \tag*{\textbf{defn. {\tt id}}}
\end{align*}
** Proving Composition
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}fmap\ (f ∘ g)\ {\tt x}             \\
 &= fmap\ (f ∘ g)\ ({\tt Identity\ x′})
    \tag*{\textbf{unfold {\tt x}}}                   \\
 &= {\tt Identity}\ ((f ∘ g)\ {\tt x′})
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= {\tt Identity}\ (f (g ({\tt x′})))
    \tag*{\textbf{defn. ∘}}                          \\
 &= fmap\ f\ ({\tt Identity} (g ({\tt x′})))
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= fmap\ f\ (fmap\ g\ ({\tt Identity\ x′}))
    \tag*{\textbf{defn. {\tt fmap}}}                 \\
 &= fmap\ f\ (fmap\ g\ {\tt x})
    \tag*{\textbf{fold {\tt x}}}
\end{align*}
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    fmap f Nothing  = ?
    fmap f (Just x) = ?
\end{lstlisting}
#+END_LaTeX
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    fmap f Nothing  = Nothing
    fmap f (Just x) = Just (f x)
\end{lstlisting}
#+END_LaTeX
** Either                                                                             :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Left e a = Left e | Right a
\end{lstlisting}
#+END_LaTeX
** Tuple                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Pair p a = Pair p a
\end{lstlisting}
#+END_LaTeX
** Const                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Const c a = Const c
\end{lstlisting}
#+END_LaTeX
* Applicatives
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Applicatives}
** Applicative laws
*** 1. Identity law                                                                :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( pure\ id ⊗ v = v \)
*** 2. Composition law                                                             :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( pure\ (∘) ⊗ u ⊗ v ⊗ w = u ⊗ (v ⊗ w) \)
*** 3. Homomorphism law                                                            :B_definition:
:PROPERTIES:
:BEAMER_act: <3->
:BEAMER_env: definition
:END:
\( pure\ f ⊗ pure\ x = pure\ (f(x)) \)
** Applicative laws
*** 4. Interchange law                                                             :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( u ⊗ pure\ y = pure\ (\$\ y) ⊗ u \)
*** 5. Functor relation law                                                        :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( fmap\ f\ x = pure\ f ⊗ x \)
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Applicative Identity where
    pure x = Identity x
    Identity f <*> Identity x = ?
\end{lstlisting}
#+END_LaTeX
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Applicative Identity where
    pure x = Identity x
    Identity f <*> Identity x = Identity (f x)
\end{lstlisting}
#+END_LaTeX
** Proving Identity
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}pure\ id ⊗ {\tt v}                 \\
 &= pure\ id ⊗ {\tt Identity\ v}
    \tag*{\textbf{unfold {\tt v}}}                   \\
 &= {\tt Identity}\ id ⊗ {\tt Identity\ v}
    \tag*{\textbf{defn. {\tt pure}}}                 \\
 &= {\tt Identity}\ (id\ {\tt v})
    \tag*{\textbf{defn. ⊗}}                          \\
 &= {\tt Identity\ v}
    \tag*{\textbf{defn. {\tt id}}}                   \\
 &= {\tt v}
    \tag*{\textbf{fold {\tt v}}}
\end{align*}
** Proving Homomorphism
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}pure\ f ⊗ pure\ x                 \\
 &= {\tt Identity}\ f ⊗ {\tt Identity}\ x
    \tag*{\textbf{defn. {\tt pure}}}                 \\
 &= {\tt Identity}\ (f(x))
    \tag*{\textbf{defn. ⊗}}                          \\
 &= pure\ (f(x))
    \tag*{\textbf{defn. {\tt pure}}}
\end{align*}
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Applicative Maybe where
    pure x = ?

    Nothing <*> Nothing = ?
    Just f  <*> Nothing = ?
    Nothing <*> Just x  = ?
    Just f  <*> Just x  = ?
\end{lstlisting}
#+END_LaTeX
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Applicative Maybe where
    pure x = ?

    Just f <*> Just x = Just (f x)
    _      <*> _      = Nothing
\end{lstlisting}
#+END_LaTeX
** Either                                                                             :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Left e a = Left e | Right a
\end{lstlisting}
#+END_LaTeX
** Tuple                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Pair p a = Pair p a
\end{lstlisting}
#+END_LaTeX
** Const                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
**Const** requires a trickier instance.
\vspace{1.5ex}
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Const c a = Const c

instance Monoid c
    => Applicative (Const c) where
    pure x = ?
    Const a <*> Const b = ?
\end{lstlisting}
#+END_LaTeX
* Monads
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Monads}
** Two formulations
*** Using bind                                                                     :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
return :: m a
(>>=)  :: m a -> (a -> m b) -> m b
\end{lstlisting}
#+END_LaTeX
*** Using join                                                                     :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
return :: m a
join   :: m (m a) -> m a
\end{lstlisting}
#+END_LaTeX
** Bind in terms of join                                                           :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
*** \vspace*{-3.5ex}                                                                  :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
m >>= f = join (fmap f m)
\end{lstlisting}
#+END_LaTeX
** Monad laws
*** 1. Left identity law                                                           :B_definition:
:PROPERTIES:
:BEAMER_env: definition
:END:
\( return\ a >>= f = f a \)
*** 2. Right identity Law                                                          :B_definition:
:PROPERTIES:
:BEAMER_act: <2->
:BEAMER_env: definition
:END:
\( m >>= return = m \)
*** 3. Associativity Law                                                           :B_definition:
:PROPERTIES:
:BEAMER_act: <3->
:BEAMER_env: definition
:END:
\( (m >>= f) >>= g = m >>= (λx → f\ x >>= g) \)
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    Identity m >>= f = ?
\end{lstlisting}
#+END_LaTeX
*** note                                                                                 :B_note:
:PROPERTIES:
:BEAMER_env: note
:END:
Identity as a concept can be used to implement "taintedness", to force
laziness, to provide singletons, and more.  As should be clear by now, the
simplicity of a core idea can be misleading.
** Identity                                                                           :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Identity a = Identity a

instance Functor Identity where
    Identity m >>= f = f m
\end{lstlisting}
#+END_LaTeX
** Proving Left Identity
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}return\ {\tt a} >>= f              \\
 &= {\tt Identity\ a} >>= f
    \tag*{\textbf{defn. {\tt return}}}               \\
 &= f\ {\tt a}
    \tag*{\textbf{defn. {\tt >>=}}}
\end{align*}
** Proving Right Identity
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}{\tt m} >>= return                 \\
 &= {\tt Identity\ m′} >>= return
    \tag*{\textbf{unfold {\tt m}}}                   \\
 &= return\ {\tt m′}
    \tag*{\textbf{defn. {\tt >>=}}}                  \\
 &= {\tt Identity\ m′}
    \tag*{\textbf{defn. {\tt return}}}               \\
 &= {\tt m}
    \tag*{\textbf{fold {\tt m}}}
\end{align*}
** Proving Associativity
\fontsize{12}{16}\selectfont
\begin{align*}
 &  \hspace{1.3em}(m >>= f) >>= g                    \\
 &= ({\tt Identity\ m′} >>= f) >>= g
    \tag*{\textbf{unfold {\tt m}}}                   \\
 &= f\ {\tt m′} >>= g
    \tag*{\textbf{defn. {\tt >>=}}}                  \\
 &= (λx → f\ x >>= g)\ {\tt m′}
    \tag*{\textbf{η-expansion}}                      \\
 &= {\tt Identity\ m′} >>= (\textbackslash x → f\ x >>= g)
    \tag*{\textbf{defn. {\tt >>=}}}                  \\
 &= m >>= (λx → f\ x >>= g)
    \tag*{\textbf{fold {\tt m}}}
\end{align*}
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    Nothing >>= f = ?
    Just x  >>= f = ?
\end{lstlisting}
#+END_LaTeX
** Maybe                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Maybe a = Nothing | Just a

instance Functor Maybe where
    Nothing >>= f = Nothing
    Just x  >>= f = Just (f x)
\end{lstlisting}
#+END_LaTeX
** Either                                                                             :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Left e a = Left e | Right a
\end{lstlisting}
#+END_LaTeX
** Tuple                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
#+BEGIN_LaTeX
\begin{lstlisting}[language=Haskell]
data Pair p a = Pair p a
\end{lstlisting}
#+END_LaTeX
** Const                                                                              :B_example:
:PROPERTIES:
:BEAMER_env: example
:END:
Why can't it be a monad?
* Free Monads
** HEAD
:PROPERTIES:
:BEAMER_opt: plain
:BEAMER_env: frame
:END:
\head{Free Monads}
* Colophon

#+STARTUP: beamer
#+STARTUP: content fninline hidestars

#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [utf8x,notes,17pt]

#+BEAMER_THEME: [height=16mm] Rochester
#+BEAMER_COLOR: seahorse

#+OPTIONS:   H:2 toc:nil

#+BEAMER_HEADER: \setbeamertemplate{navigation symbols}{}
#+BEAMER_HEADER: \usepackage{courier}
#+BEAMER_HEADER: \usepackage{helvet}
#+BEAMER_HEADER: \usepackage{listings}
#+BEAMER_HEADER: \usepackage{mathtools}
#+BEAMER_HEADER: \usepackage{pdfcomment}

#+BEAMER_HEADER: \SetUnicodeOption{mathletters}
#+BEAMER_HEADER: \DeclareUnicodeCharacter{952}{\theta}

#+BEAMER_HEADER: \lstset{
#+BEAMER_HEADER:     keywordstyle=\color{blue}
#+BEAMER_HEADER:   , basicstyle=\ttfamily\small
#+BEAMER_HEADER:   , commentstyle={}
#+BEAMER_HEADER:   , columns=fullflexible
#+BEAMER_HEADER:   , showstringspaces=false
#+BEAMER_HEADER:   , keepspaces=true=
#+BEAMER_HEADER:   , breaklines=true
#+BEAMER_HEADER:   }

#+BEAMER_HEADER: \newcommand{\head}[1]{\begin{center}
#+BEAMER_HEADER: \vspace{13mm}\hspace{-1mm}\Huge{{#1}}
#+BEAMER_HEADER: \end{center}}

#+BEAMER_HEADER: \renewcommand{\note}[1]{\marginnote{\pdfcomment[icon=note]{#1}}}

#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+COLUMNS: %20ITEM %13BEAMER_env(Env) %6BEAMER_envargs(Args) %4BEAMER_col(Col) %7BEAMER_extra(Extra)
